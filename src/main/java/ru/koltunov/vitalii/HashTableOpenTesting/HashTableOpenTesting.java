package ru.koltunov.vitalii.HashTableOpenTesting;

import java.util.ArrayList;
import java.util.Objects;
import java.util.Scanner;

class Main {
    private static final boolean debugMode = true;

    public static void main(String[] args) {
        scannerTest();
//        simpleTest();
    }

    public static void simpleTest() {
        HashTableOpenTesting h1 = new HashTableOpenTesting();
    }

    public static void scannerTest() {
        HashTableOpenTesting h1 = new HashTableOpenTesting();
        Scanner scanner = new Scanner(System.in);
        int requests = scanner.nextInt();
        for (int i = 0; i < requests; i++) {
            String cmd = scanner.nextLine();
            String[] s = cmd.split(" ");
            if (debugMode)
                System.out.println("  " + cmd);
            switch (s[0]) {
                case "push" -> h1.push(s[1]);
                case "search" -> {
                    if (h1.search(s[1])) {
                        debugPrintln("TRUE");
                    } else {
                        debugPrintln("FALSE");
                    }
                }
                case "pop" -> {
                    if (h1.pop(s[1])) {
                        debugPrintln("TRUE");
                    } else {
                        debugPrintln("FALSE");
                    }
                }
            }
        }
    }

    // ======================================== debug =====================================
    private static int outputLineNo = 0;

    private static void debugPrintln(String s) {
        outputLineNo++;
        if (debugMode) {
            System.out.print(outputLineNo + ": ");
        }
        System.out.println(s);
    }

    private static void debugPrintln(int i) {
        outputLineNo++;
        if (debugMode) {
            System.out.print(outputLineNo + ": ");
        }
        System.out.println(i);
    }

// ====================================================================================

}

public class HashTableOpenTesting {
    static final int seed = 3;
    private final static int threshold = 2;
    int capacity = 5;
    int filledElem = 0;
    ArrayList<Node> hashTable;

    public HashTableOpenTesting() {
        this.hashTable = new ArrayList<>();
        for (int i = 0; i < capacity; i++) {
            hashTable.add(new Node());
        }
    }

    public static int hashF1(String s, int capacity) {
        int prime = 37;
        int hash = 0;

        for (int i = 0; i < s.length(); i++) {
            hash += prime * (i + 7);
            prime = prime * (seed + 3);
        }
        return (hash < 0 ? -hash: hash)  % capacity;
    }

    public static int hashF2(String s, int capacity) {
        int prime = 19;
        int hash = 0;

        for (int i = 0; i < s.length(); i++) {
            hash += prime * (i + 3);
            prime = prime * (seed + 5);
        }
        return (hash < 0 ? -hash: hash) % capacity;
    }

    boolean search(String s) {
        int hashF1 = hashF1(s, capacity);
        int hashF2 = hashF2(s, capacity);
        int inx = hashF1;
        int countIterations = 0;
        for (int i = 0; i < capacity; i++) {
            while (countIterations < hashTable.size()) {
                if (Objects.equals(hashTable.get(inx).data, s) && hashTable.get(inx).filled) {
                    return true;
                }
                inx = (inx + (i + 1) * hashF2) % hashTable.size();
//                inx = hashF2;
                countIterations++;
//                if (countIterations >= hashTable.size()) {
//                    return false;
//                }
            }
        }
        return false;
    }

    void push(String s) {
        resize();
        int hashF1 = hashF1(s, capacity);
        int hashF2 = hashF2(s, capacity);
        int inx = hashF1;
        int countIterations = 0;
        for (int i = 0; i < capacity; i++) {
            while (countIterations < capacity){
                if (!hashTable.get(inx).filled) {
                    hashTable.get(inx).data = s;
                    hashTable.get(inx).filled = true;
                    filledElem++;
                    return;
                }
                if (hashTable.get(inx).filled && Objects.equals(hashTable.get(inx).data, s)) {
                    return;
                }
                inx = (inx + (i + 1) * hashF2) % hashTable.size();
                countIterations++;
            }
        }

    }

    boolean pop(String s) {
        int hashF1 = hashF1(s, capacity);
        int hashF2 = hashF2(s, capacity);
        int inx = hashF1;
        int countIterations = 0;
        for (int i = 0; i < capacity; i++) {
            while (countIterations < hashTable.size()) {
                if (Objects.equals(hashTable.get(inx).data, s) && hashTable.get(inx).filled) {
                    hashTable.get(inx).filled = false;
                    hashTable.get(inx).data = "";
                    filledElem--;
                    return true;
                }
                inx = (inx + (i+ 1) * hashF2) % hashTable.size();
//                inx = hashF2;
                countIterations++;
                if (countIterations >= hashTable.size()) {
                    return false;
                }
            }
        }
        return false;
    }

    void resize() {
        if (capacity < filledElem * threshold) {
            ArrayList<Node> hashTableOld = hashTable;
            capacity = capacity * threshold;
            this.hashTable = new ArrayList<>(capacity);
            for (int i = 0; i < capacity; i++) {
                hashTable.add(new Node());
            }
            for (int i = 0; i < hashTableOld.size(); i++) {
                if (hashTableOld.get(i).filled) {
                    hashTable.add(i, hashTableOld.get(i));
                }
            }
        }
    }

    @Override
    public String toString() {
        return "HashTab{" + "capacity=" + capacity + ", elems=" + filledElem + ", hashTable=" + hashTable + '}';
    }
}

class Node {
    boolean filled = false;
    String data;

    public Node() {
    }

    @Override
    public String toString() {
        if (filled) return "'" + data + "'";
        else return "-";
    }
}
