package ru.koltunov.vitalii.HashTableOpenTesting;

import java.io.*;
import java.util.ArrayList;
import java.util.Objects;
import java.util.Scanner;
import java.util.StringJoiner;

class Main {
    private static final boolean debugMode = false;

    public static void main(String[] args) throws FileNotFoundException {
        scannerTest();
//        simpleTest();
    }
    public static void simpleTest() {
        HashTableOpenTesting h1 = new HashTableOpenTesting();
    }

    private static final HashTableOpenTesting hashTable = new HashTableOpenTesting();

    public static void scannerTest() {
        Scanner scanner = new Scanner(System.in);
        int requests = scanner.nextInt();
        scanner.nextLine();
        for (int i = 0; i < requests; i++) {
            String cmd = scanner.nextLine();
            String[] s = cmd.split(" ");
            if (debugMode)
                printCmd(cmd);
            switch (s[0]) {
                case "push" -> hashTable.push(s[1]);
                case "search" -> debugPrintln(hashTable.search(s[1]));
                case "pop" ->  debugPrintln(hashTable.pop(s[1]));
            }
            if (debugMode)
                System.out.println(hashTable);
        }
    }

    // ======================================== debug =====================================
    private static void printCmd(String cmd) {
        System.out.println("  " + cmd);
    }

    private static int outputLineNo = 0;

    private static void debugPrintln(String s) {
        outputLineNo++;
        if (debugMode) {
            System.out.print(outputLineNo + ": ");
        }
        System.out.println(s);
    }

    private static void debugPrintln(boolean b) {
        outputLineNo++;
        if (debugMode) {
            System.out.print(outputLineNo + ": ");
        }
        System.out.println(b ? "TRUE" : "FALSE");
    }

// ====================================================================================
}

public class HashTableOpenTesting {
    private static final int probeStep = 17; // должно быть простым числом

    static final int seed = 37;
    private final static int threshold = 2;
    int initialCapacity = 5;
    int elems = 0;

    ArrayList<Node> hashTable;

    public HashTableOpenTesting() {
        this.hashTable = new ArrayList<>();
        for (int i = 0; i < initialCapacity; i++) {
            hashTable.add(new Node());
        }
    }

    public int hashF1(String s) {
        int prime = 41;
        int hash = 0;

        for (int i = 0; i < s.length(); i++) {
            hash += prime * (i + 47) + s.charAt(i);
            prime = prime * (seed + 53);
        }
        return (hash < 0 ? -hash: hash)  % this.hashTable.size();
    }

    public int hashF2(String s) {
        int prime = 59;
        int hash = 0;

        for (int i = 0; i < s.length(); i++) {
            hash += prime * (i + 67) + s.charAt(i);
            prime = prime * (seed + 71);
        }
        return (hash < 0 ? -hash: hash) % hashTable.size();
    }

    boolean search(String s) {
        int inx = hashF1(s);
        int step = hashF2(s);
        int countIterations = 0;

        while (hashTable.get(inx).filled && countIterations < hashTable.size()){
            if (!hashTable.get(inx).deleted && Objects.equals(hashTable.get(inx).data, s)) {
                return true;
            }
            inx = (inx + step) % hashTable.size();
            step = probeStep;
            countIterations++;
        }
        return false;
    }

    void push(String s) {
        resize();
        int inx = hashF1(s);
        int step = hashF2(s);
        int countIterations = 0;

        while (hashTable.get(inx).filled && countIterations < hashTable.size()){
            if (Objects.equals(hashTable.get(inx).data, s)) {
                hashTable.get(inx).deleted = false;
                elems++;
                return;
            }
            inx = (inx + step) % hashTable.size();
            step = probeStep;
            countIterations++;
        }
        assert countIterations < initialCapacity;
        hashTable.get(inx).data = s;
        hashTable.get(inx).filled = true;
        hashTable.get(inx).deleted = false;
        elems++;
    }

    boolean pop(String s) {
        int inx = hashF1(s);
        int step = hashF2(s);
        int countIterations = 0;

        while (hashTable.get(inx).filled && countIterations < hashTable.size()){
            if (!hashTable.get(inx).deleted && Objects.equals(hashTable.get(inx).data, s)) {
                hashTable.get(inx).deleted = true;
                elems--;
                return true;
            }
            inx = (inx + step) % hashTable.size();
            step = probeStep;
            countIterations++;
        }
        return false;
    }

    void resize() {
        if (elems * threshold > hashTable.size()) {
            ArrayList<Node> hashTableOld = hashTable;
            int newCapacity = hashTable.size() * threshold;
            this.hashTable = new ArrayList<>(newCapacity);
            elems = 0;
            for (int i = 0; i < newCapacity; i++) {
                hashTable.add(new Node());
            }
            for (Node node : hashTableOld) {
                if (!node.deleted) {
                    push(node.data);
                }
            }
        }
    }

    @Override
    public String toString() {
        StringJoiner sj = new StringJoiner(" ",
                "    ht " + elems + '/' + hashTable.size(),"");
        int i = 0;
        for (Node n: hashTable) {
            if (!n.deleted)
                sj.add("\n      " + i + "=>" + n.data);
            i++;
        }
        return sj.toString();
    }
}

class Node {
    boolean filled = false;
    boolean deleted = true;
    String data;
    @Override
    public String toString() {
        if (filled) return "'" + data + "'";
        else return "-";
    }
}
